---
description: Toda vez que for mecionado algo como arquitetura ou dominio (DDD). Ou quando for alterado algo arquitetural.
globs:
alwaysApply: false
---
# Arquitetura DDD - Domain-Driven Design

## PadrÃ£o Arquitetural

Este projeto implementa **Domain-Driven Design (DDD)**, separando claramente domÃ­nio e implementaÃ§Ã£o.

## Regras CrÃ­ticas

### âœ… SEMPRE FAZER:

1. **Use Cases sempre retornam Entities**
   - Nunca retorne dados do banco diretamente
   - Sempre mapeie para entities do domÃ­nio

2. **Repositories sempre retornam Entities**
   - Use mappers para converter dados do banco para entities
   - Mantenha a abstraÃ§Ã£o do repositÃ³rio

3. **Estrutura de pastas obrigatÃ³ria:**
   ```
   app/features/[feature]/
   â”œâ”€â”€ entities/          # Classes de domÃ­nio
   â”œâ”€â”€ repositories/      # Interfaces (abstraÃ§Ãµes)
   â”œâ”€â”€ use-cases/         # LÃ³gica de negÃ³cio
   â”œâ”€â”€ mappers/          # ConversÃ£o entre camadas
   â””â”€â”€ types.ts          # Tipos especÃ­ficos
   ```

4. **InjeÃ§Ã£o de dependÃªncia**
   - Use `@injectable()` em use cases
   - Use `@inject()` para dependencies
   - Configure no [container.ts](mdc:app/lib/container.ts)

### âŒ NUNCA FAZER:

1. Use cases retornando dados do Prisma diretamente
2. Entities dependendo de infraestrutura
3. LÃ³gica de negÃ³cio nos repositories
4. ImplementaÃ§Ãµes concretas no domÃ­nio

---

## ğŸ—ï¸ Estrutura Arquitetural Completa

### Camadas da Arquitetura

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   WEB LAYER                     â”‚
â”‚              (Routes, Controllers)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               USE CASES LAYER                   â”‚
â”‚            (Business Logic)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               DOMAIN LAYER                      â”‚
â”‚            (Entities, Types)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            INFRASTRUCTURE LAYER                 â”‚
â”‚          (Database, External APIs)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Estrutura de Pastas Detalhada

```
app/features/[feature]/
â”œâ”€â”€ entities/           # Entidades do domÃ­nio
â”œâ”€â”€ repositories/       # Interfaces dos repositÃ³rios (abstraÃ§Ãµes)
â”œâ”€â”€ use-cases/          # Casos de uso (regras de negÃ³cio)
â”œâ”€â”€ mappers/            # Mapeamento entre camadas
â”œâ”€â”€ services/           # ServiÃ§os de domÃ­nio
â””â”€â”€ types.ts            # Tipos especÃ­ficos da feature

app/database/           # ImplementaÃ§Ãµes concretas dos repositÃ³rios
app/lib/container.ts    # ConfiguraÃ§Ã£o de injeÃ§Ã£o de dependÃªncia
```

## ğŸ”§ Componentes da Arquitetura

### 1. **Entities (Entidades do DomÃ­nio)**

As entidades representam os conceitos centrais do negÃ³cio e encapsulam as regras de domÃ­nio.

**Exemplo:** [Goal Entity](mdc:app/features/goals/entities/goal.ts)
```typescript
export class Goal {
  readonly id: string;
  readonly title: string;
  readonly description: string;
  // ... outros campos

  constructor(props: GoalProps) {
    this.id = props.id;
    this.title = props.title;
    // ... inicializaÃ§Ã£o
  }

  static create(props: Omit<GoalProps, "id">) {
    return new Goal({
      ...props,
      id: crypto.randomUUID(),
    });
  }
}
```

**CaracterÃ­sticas:**
- ImutÃ¡veis (readonly properties)
- ContÃªm regras de negÃ³cio
- Factory methods para criaÃ§Ã£o (`create`)
- NÃ£o dependem de infraestrutura

### 2. **Repository Interfaces (Contratos)**

AbstraÃ§Ãµes que definem como os dados devem ser acessados, sem especificar a implementaÃ§Ã£o.

**Exemplo:** [GoalRepository Interface](mdc:app/features/goals/repositories/goal.ts)
```typescript
export abstract class GoalRepository {
  abstract createGoal(goal: Goal): Promise<Goal>;
  abstract findById(id: string): Promise<Goal | null>;
  abstract findAll(): Promise<Goal[]>;
  abstract deleteById(id: string): Promise<void>;
  abstract updateById(id: string, data: UpdateData): Promise<Goal>;
}
```

**CaracterÃ­sticas:**
- Sempre trabalham com **Entities**
- Definem contratos, nÃ£o implementaÃ§Ãµes
- Localizada na camada de domÃ­nio

### 3. **Use Cases (Casos de Uso)**

Encapsulam a lÃ³gica de negÃ³cio e orquestram as operaÃ§Ãµes entre entities e repositories.

**Exemplo:** [CreateGoalFromMessageUseCase](mdc:app/features/goals/use-cases/create-goal-from-message.server.ts)
```typescript
@injectable()
export class CreateGoalFromMessageUseCase {
  constructor(
    @inject(GoalRepository)
    private readonly goalRepository: GoalRepository,
    @inject(ChatMessageRepository)
    private readonly chatMessageRepository: ChatMessageRepository,
  ) {}

  async execute({ messageId }: CreateGoalFromMessageInput): Promise<Goal> {
    // 1. Buscar mensagem
    const message = await this.chatMessageRepository.findById(messageId);

    // 2. ValidaÃ§Ãµes de negÃ³cio
    if (!message?.content?.data) {
      throw new Error("ConteÃºdo da mensagem nÃ£o encontrado");
    }

    // 3. Criar entity do domÃ­nio
    const goal = Goal.create({
      title: content.data.title,
      description: content.data.description,
      // ... outros campos
    });

    // 4. Persistir e retornar entity
    return await this.goalRepository.createGoal(goal);
  }
}
```

**CaracterÃ­sticas:**
- Sempre retornam **Entities**
- ContÃªm a lÃ³gica de negÃ³cio
- Dependem apenas de abstraÃ§Ãµes (interfaces)
- Usam injeÃ§Ã£o de dependÃªncia

### 4. **Repository Implementations (ImplementaÃ§Ãµes Concretas)**

ImplementaÃ§Ãµes especÃ­ficas dos contratos de repository, isoladas da lÃ³gica de negÃ³cio.

**Exemplo:** [PrismaGoalRepository](mdc:app/database/goal.repository.ts)
```typescript
export class PrismaGoalRepository extends GoalRepository {
  constructor(@inject(PrismaClient) private readonly prisma: PrismaClient) {
    super();
  }

  async createGoal(goal: Goal): Promise<Goal> {
    // Mapear para formato do banco
    const goalData = await this.prisma.client.goal.create({
      data: GoalsMapper.toPrisma(goal),
    });

    // Retornar entity do domÃ­nio
    return GoalsMapper.toDomain(goalData);
  }
}
```

**CaracterÃ­sticas:**
- Implementam as interfaces de repository
- Fazem mapeamento entre entities e dados persistidos
- Sempre retornam **Entities** do domÃ­nio
- Isoladas na camada de infraestrutura

### 5. **Mappers (Mapeadores)**

ResponsÃ¡veis pela conversÃ£o entre diferentes representaÃ§Ãµes dos dados.

**Exemplo:** [GoalsMapper](mdc:app/features/goals/mappers/goals.ts)
```typescript
export const GoalsMapper = {
  toDomain(goal: PrismaGoal): Goal {
    return new Goal({
      id: goal.id,
      title: goal.title,
      // ... mapeamento completo
    });
  },

  toPrisma(goal: Goal): Prisma.GoalCreateInput {
    return {
      id: goal.id,
      title: goal.title,
      // ... mapeamento completo
    };
  }
};
```

### 6. **Dependency Injection Container**

Configura as dependÃªncias e resolve as abstraÃ§Ãµes.

**Exemplo:** [Container](mdc:app/lib/container.ts)
```typescript
export const container = new Container({ autobind: true });

container.bind(GoalRepository).to(PrismaGoalRepository).inSingletonScope();
```

## ğŸš€ Fluxo de ExecuÃ§Ã£o

1. **Route** recebe a requisiÃ§Ã£o
2. **Route** instancia o **Use Case** via container
3. **Use Case** executa a lÃ³gica de negÃ³cio
4. **Use Case** interage com **Repositories** (abstraÃ§Ãµes)
5. **Repository Implementation** acessa dados
6. **Mappers** convertem dados para **Entities**
7. **Use Case** retorna **Entity**
8. **Route** pode mapear **Entity** para resposta HTTP

## âœ… BenefÃ­cios da Arquitetura

### 1. **Testabilidade**
- Use cases podem ser testados isoladamente
- Repositories podem ser mockados facilmente
- Entities contÃªm lÃ³gica pura

### 2. **Flexibilidade**
- ImplementaÃ§Ãµes podem ser trocadas sem afetar o domÃ­nio
- Facilita migraÃ§Ã£o de banco de dados
- Permite diferentes estratÃ©gias de persistÃªncia

### 3. **Manutenibilidade**
- SeparaÃ§Ã£o clara de responsabilidades
- CÃ³digo organizado por contextos de negÃ³cio
- Baixo acoplamento entre camadas

### 4. **Escalabilidade**
- Novas features seguem o mesmo padrÃ£o
- Facilita trabalho em equipe
- Reduz complexidade cognitiva

## ğŸ“‹ Exemplo PrÃ¡tico: Criando uma Nova Feature

### 1. Criar a Entity
```typescript
// app/features/tasks/entities/task.ts
export class Task {
  constructor(private props: TaskProps) {}

  static create(props: Omit<TaskProps, "id">) {
    return new Task({ ...props, id: crypto.randomUUID() });
  }
}
```

### 2. Definir o Repository Interface
```typescript
// app/features/tasks/repositories/task.ts
export abstract class TaskRepository {
  abstract create(task: Task): Promise<Task>;
  abstract findById(id: string): Promise<Task | null>;
}
```

### 3. Implementar o Repository
```typescript
// app/database/task.repository.ts
export class PrismaTaskRepository extends TaskRepository {
  async create(task: Task): Promise<Task> {
    const data = await this.prisma.task.create({
      data: TasksMapper.toPrisma(task)
    });
    return TasksMapper.toDomain(data);
  }
}
```

### 4. Criar Use Case
```typescript
// app/features/tasks/use-cases/create-task.server.ts
@injectable()
export class CreateTaskUseCase {
  constructor(
    @inject(TaskRepository)
    private taskRepository: TaskRepository
  ) {}

  async execute(input: CreateTaskInput): Promise<Task> {
    const task = Task.create(input);
    return await this.taskRepository.create(task);
  }
}
```

### 5. Configurar DI
```typescript
// app/lib/container.ts
container.bind(TaskRepository).to(PrismaTaskRepository);
```

## ğŸ”„ Status da MigraÃ§Ã£o

Este projeto estÃ¡ em processo de migraÃ§Ã£o para este padrÃ£o. Alguns use cases ainda nÃ£o seguem completamente essas regras e serÃ£o refatorados gradualmente.

### Status Atual:
- âœ… Goal domain - Seguindo padrÃ£o
- âš ï¸ Outros domains - Em refatoraÃ§Ã£o

---

**Ãšltima atualizaÃ§Ã£o:** Janeiro 2025
